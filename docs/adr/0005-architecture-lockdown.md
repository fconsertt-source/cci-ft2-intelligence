# ADR 0005 — تثبيت المعمارية وحدود الطبقات (Architecture Lockdown)

تاريخ: 2026-02-01
الحالة: معتمد (Accepted)

## 1. السياق (Context)

بعد الانتهاء من مراحل إعادة الهيكلة المعمارية، وصل المشروع إلى حالة استقرار كاملة (100% Safe State) مع نجاح جميع الاختبارات (Unit, Integration, Contract, Snapshot). تم توحيد طبقة `Core` داخل `Domain`، وعزل المكونات القديمة (`Legacy`)، وتوضيح الحدود بين الطبقات.

للحفاظ على هذه الحالة الصحية ومنع "الزحف المعماري" (Architectural Drift) مستقبلاً، أصبح من الضروري تثبيت هذه المعمارية بوثيقة مرجعية واضحة تُستخدم كعقد (Contract) يحميه الـ CI ويمنع أي تراجع معماري.

## 2. القرار (Decision)

يعتمد المشروع معمارية نظيفة (Clean Architecture) بحدود صارمة (Strict Boundaries). يتم اعتماد القواعد التالية كمعيار هندسي غير قابل للتفاوض إلا عبر ADR جديد. أي كسر لهذه القواعد يُعتبر Bug معماري وليس Feature. أي كسر لهذه القواعد يُعتبر Bug معماري وليس Feature.

### أ. حدود الطبقات (Layer Boundaries)

1.  **Domain Layer (`src/domain`)**:
    *   **المسؤولية**: قواعد العمل الأساسية، الكيانات (Entities)، كائنات القيمة (Value Objects)، خدمات النطاق (Domain Services)، وقواعد العمل (Business Rules).
    *   **الاعتماديات**: لا تعتمد على أي طبقة خارجية (Pure Python/Framework-agnostic).
    *   **الممنوعات**: يُمنع منعًا باتًا استيراد أي شيء من `infrastructure`، `application`، `presentation`، أو أي منطق يتعلق بالإدخال/الإخراج (IO).

2.  **Application Layer (`src/application`)**:
    *   **المسؤولية**: تنسيق وتنفيذ حالات الاستخدام (Use Cases)، وتعريف كائنات نقل البيانات (DTOs) والمنافذ (Ports/Interfaces).
    *   **الاعتماديات**: تعتمد فقط على طبقة `Domain`.
    *   **المخرجات**: يجب أن تُعيد حالات الاستخدام كائنات DTOs فقط (Immutable Data Classes)، ولا تُعيد كيانات `Domain` أبدًا لمنع التسريب.
    *   **الممنوعات**: لا تحتوي على أي تفاصيل تقنية (تخزين، شبكة، واجهة مستخدم).

3.  **Infrastructure Layer (`src/infrastructure`)**:
    *   **المسؤولية**: التنفيذ التقني للواجهات (Adapters)، مثل الوصول لقاعدة البيانات، التعامل مع الملفات، تسجيل الدخول (Logging)، والتكامل مع الأدوات الخارجية.
    *   **الاعتماديات**: تنفذ الواجهات (Interfaces) المعرفة في `Application` وتعتمد على `Domain`.

4.  **Presentation/Reporting Layer (`scripts/`, `src/reporting/`)**:
    *   **المسؤولية**: عرض البيانات للمستخدم النهائي (CLI, PDF, CSV). تُعامل كـ "Adapter" خارجي.
    *   **البيانات**: تستهلك DTOs من خلال `Application` (Use Cases) فقط. يمنع استيراد `src.domain.entities` مباشرة.

### ب. الحماية عبر CI (CI Guard Rails)

يتم فرض هذه الحدود بشكل آلي عبر конвейер CI/CD باستخدام:
*   **اختبارات هيكلية (Structural Tests)**: للتحقق من اتجاه الاعتماديات بين الطبقات.
*   **اختبارات عدم تسريب الكيانات (No-Entity-Leak Tests)**: للتأكد من أن طبقة التطبيق لا تسرب كيانات النطاق.
*   **اختبارات اللقطة (Snapshot Tests)**: لتثبيت مخرجات التقارير وضمان عدم تغيرها بشكل غير متوقع.
أي خرق لهذه القواعد يؤدي إلى فشل بناء المشروع مباشرة.

### ج. إدارة الأدوات القديمة (Legacy Management)

*   أي كود لا يلتزم بالمعمارية النظيفة (مثل `simulate_vvm_scenarios.py`) يجب وضعه في `tools/legacy/`.
*   يتم استثناء هذا المجلد من قواعد الحماية المعمارية، ولكنه يظل معزولًا تمامًا عن كود الإنتاج النظيف.

## 3. العواقب (Consequences)

*   **الإيجابيات**:
    *   استقرار معماري عالي وقابلية للصيانة والتوسع بسهولة.
    *   فصل واضح للمسؤوليات يسهل التطوير والاختبار الموازي.
    *   مرجع واضح للمطورين الحاليين والجدد يقلل من الأخطاء.
    *   سهولة التطوير المستقبلي دون الخوف من التراجع (Regression).

*   **السلبيات**:
    *   يتطلب كتابة كود إضافي (Boilerplate) مثل DTOs و Mappers، وهو ثمن مقبول مقابل الاستقرار والجودة.
    *   صرامة أعلى تتطلب انضباطًا هندسيًا من الفريق.

## 4. حالة التنفيذ والتعديلات المستقبلية

*   **حالة التنفيذ الحالية**:
    *   **Tests**: جميع الاختبارات (93/93) تمر بنجاح.
    *   **Guard Scripts**: مفعلة وتمنع الاستيرادات الخاطئة.
    *   **Legacy Code**: معزول تمامًا في مجلده الخاص.

*   **التعديلات المستقبلية**:
    *   أي تعديل معماري جذري يتطلب فتح ADR جديد ومناقشته.
    *   يجب تحديث اختبارات الحماية المعمارية لتعكس أي تغيير معتمد.

---
**هذه الوثيقة تعتبر المرجع الرسمي والنهائي للمعمارية الحالية للمشروع.**